import uuid
import numpy as np

from controller import Controller
from event import Event, RideRequest, PickupDropoff, VisualizationRequest
from action import Action
from vehicle import VehiclePlan, VehiclePlanEntry, VehicleState

class RandomTaxiController(Controller):
    """
    Simple (& Stupid) Controller: no ride-sharing = Taxi, Random assignment of vehicles

    Attributes
    ----------
    _location_ids: set[uuid.UUID]
        (private) set of all possible location IDs
    _vehicle_ids: set[uuid.UUID]
        (private) set of all possible vehicle IDs
    _vehicle_ids_ordered: list[uuid.UUID]
        (private) ordered list of all possible vehicle IDs
    _vehicle_plans: dict[uuid.UUID, VehiclePlan]
        (private) storage of the vehicle plans as generated by the controller

    _rng: np.random.Generator
        (private) random number generator
    """

    def __init__(self,
                 locations: set[uuid.UUID],
                 vehicles: set[uuid.UUID]):
        # assign parameters
        self._location_ids: set[uuid.UUID] = locations
        self._vehicle_ids: set[uuid.UUID] = vehicles
        self._vehicle_ids_ordered: list[uuid.UUID] = list(vehicles)

        self._vehicle_plans: dict[uuid.UUID, VehiclePlan] = dict()
        for id in self._vehicle_ids:
            self._vehicle_plans[id] = VehiclePlan()

        self._rng = np.random.default_rng(seed=42)

    def process_event(self,
                      event: Event) -> Action:
        """
        Processes an avent and generates an action  
        = Control Loop
        """
        action = None

        if event is None:
            return action
        
        if isinstance(event, RideRequest):
            action = self._process_riderequest(event)
        elif isinstance(event, PickupDropoff):
            action = self._process_pickupdropoff(event)
        elif isinstance(event, VisualizationRequest):
            pass #could add in custom controler visualization that is timed with environment
        else:
            raise NotImplementedError(f"The event of type "+
                                      f"{type(event)} is not implemented.")
        
        return action
    
    def _process_riderequest(self,
                             event: RideRequest) -> Action:
        """
        Process RideRequest Event

        Assign Vehicle to Passenger (completely randomly!)
        Ensure that Driving
        """
        # generate vehicle plan entries
        entry_pickup = VehiclePlanEntry(
            location=event.location_pickup,
            passenger_ids=set([event.passenger_id]),
        )
        entry_dropoff= VehiclePlanEntry(
            location=event.location_dropoff,
            passenger_ids=set() #empty set as only need to drop off
        )

        # modify vehicle plan
        position = self._rng.integers(low=0,high=len(self._vehicle_ids))
        responsible_vehicle_id = self._vehicle_ids_ordered[position]

        vehicle_plan = self._vehicle_plans[responsible_vehicle_id]
        vehicle_plan.extend([entry_pickup, entry_dropoff])
        
        return Action(
            vehicle_plans={responsible_vehicle_id: vehicle_plan},
            vehicle_states={responsible_vehicle_id: VehicleState.DRIVING} # ensure that the car is driving (it will either start or stay there)
        )

    def _process_pickupdropoff(self,
                               event: PickupDropoff) -> Action:
        """
        Process PikcupDropoff Event

        Update controller car state
        Ensure that Driving (after this event the vehicle is always idle)
        """
        vehicle_plan = self._vehicle_plans[event.vehicle_id]
        assert event.location == vehicle_plan.get_next_location(), \
            f"Dude, a vehicle arrived at {event.location} but our simplest controller "\
            +f"cannot get it right and thinks the vehicle is at {vehicle_plan.get_next_location()}."
        vehicle_plan.advance_plan() #advance plan by one step

        if len(vehicle_plan.get_plan_locations())>0:
            next_state = VehicleState.DRIVING
        else:
            next_state = VehicleState.IDLING

        return Action(
            vehicle_states={event.vehicle_id: next_state}
        )
    def update_vehicle_plans(self,
                             vehicle_plans: dict[uuid.UUID, VehiclePlan]):
        """
        Update the vehicle plan if more than one controller is acting and this controller 
        needs to keep track of vehicle plans
        """
        pass