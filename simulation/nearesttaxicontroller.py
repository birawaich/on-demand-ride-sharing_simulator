import uuid

from controller import Controller
from event import Event, RideRequest, PickupDropoff, VisualizationRequest
from action import Action
from vehicle import VehiclePlan, VehiclePlanEntry, VehicleState, Vehicle
from bielegrid_geography import BieleGridGeography
from bielegrid import BieleGrid

class NearestTaxiController(Controller):
    """
    Simple Controller: no ride-sharing = Taxi, Nearest assignment of vehicles

    Attributes
    ----------
    _location_ids: set[uuid.UUID]
        (private) set of all possible location IDs
    _vehicle_ids: set[uuid.UUID]
        (private) set of all possible vehicle IDs
    _vehicle_ids_ordered: list[uuid.UUID]
        (private) ordered list of all possible vehicle IDs
    _vehicle_ids_avail: list[uuid.UUID]
        (private) ordered list of all available vehicles IDs
    _vehicle_plans: dict[uuid.UUID, VehiclePlan]
        (private) storage of the vehicle plans as generated by the controller
    _geo: BieleGridGeography
        (private) geography object storing information about the current scenario
    _env: BieleGridEnvironment
        (private) environment object storing information about the current scenario
    _rng: np.random.Generator
        (private) random number generator
    """

    def __init__(self,
                 locations: set[uuid.UUID],
                 vehicles: set[uuid.UUID],
                 geo: BieleGridGeography,
                 env: BieleGrid):
        # assign parameters
        self._location_ids: set[uuid.UUID] = locations
        self._vehicle_ids: set[uuid.UUID] = vehicles
        self._vehicle_ids_ordered: list[uuid.UUID] = list(vehicles)
        self._vehicle_ids_avail: list[uuid.UUID] = list(vehicles) #Store idling vehicles that are going to pick up passengers
        self._vehicle_plans: dict[uuid.UUID, VehiclePlan] = dict()
        self._geo:BieleGridGeography = geo
        self._env:BieleGrid = env
        for id in self._vehicle_ids:
            self._vehicle_plans[id] = VehiclePlan()
        # set up backlog parameters
        self._backlog_requests: list[RideRequest] = [] #backlog of requests that could not be served at their request

    def process_event(self,
                      event: Event) -> Action:
        """
        Processes an avent and generates an action  
        = Control Loop
        """
        action = None

        if event is None:
            return action
        
        if isinstance(event, RideRequest):
            action = self._process_riderequest(event)
        elif isinstance(event, PickupDropoff):
            action = self._process_pickupdropoff(event)
        elif isinstance(event, VisualizationRequest):
            pass #could add in custom controler visualization that is timed with environment
        else:
            raise NotImplementedError(f"The event of type "+
                                      f"{type(event)} is not implemented.")
        
        return action
    
    def _process_riderequest(self,
                             event: RideRequest) -> Action:
        """
        Process RideRequest Event

        Assign Vehicle to Passenger to nearest available vehicle
        Ensure that Driving
        """
        #Check if there are any vehicles available
        if len(self._vehicle_ids_avail) == 0:
            # add to backlog
            self._backlog_requests.append(event)
            return Action()
        # generate vehicle plan entries
        entry_pickup = VehiclePlanEntry(
            location=event.location_pickup,
            passenger_ids=set([event.passenger_id]),
        )
        entry_dropoff= VehiclePlanEntry(
            location=event.location_dropoff,
            passenger_ids=set(),
        )
        # entry_dropoff= VehiclePlanEntry(
        #     location=event.location_dropoff,
        #     passenger_ids=set([event.passenger_id]),
        # )

        # modify vehicle plan
        pickup_location = event.location_pickup
        vehicle_location = self._env.get_vehicle_location(self._vehicle_ids_avail[0])
        min_distance = self._geo.get_distance(vehicle_location,pickup_location)
        responsible_vehicle_id = self._vehicle_ids_avail[0]
        #Assign closest free taxi
        for free_vehicle in self._vehicle_ids_avail[1:]:
            vehicle_location = self._env.get_vehicle_location(free_vehicle)
            taxi_dist = self._geo.get_distance(vehicle_location,pickup_location)
            if taxi_dist < min_distance:
                min_distance = taxi_dist
                responsible_vehicle_id = free_vehicle
        #Remove assigned taxi
        self._vehicle_ids_avail.remove(responsible_vehicle_id)

        # position = self._rng.integers(low=0,high=len(self._vehicle_ids))
        # responsible_vehicle_id = self._vehicle_ids_ordered[position]

        vehicle_plan = self._vehicle_plans[responsible_vehicle_id]
        vehicle_plan.extend([entry_pickup, entry_dropoff])
        
        return Action(
            vehicle_plans={responsible_vehicle_id: vehicle_plan},
            vehicle_states={responsible_vehicle_id: VehicleState.DRIVING} # ensure that the car is driving (it will either start or stay there)
        )

    
    def _process_pickupdropoff(self,
                               event: PickupDropoff) -> Action:
        """
        Process PikcupDropoff Event

        Update controller car state
        Ensure that Driving (after this event the vehicle is always idle)
        """
        vehicle_plan = self._vehicle_plans[event.vehicle_id]
        assert event.location == vehicle_plan.get_next_location(), \
            f"Dude, a vehicle arrived at {event.location} but our simplest controller "\
            +f"cannot get it right and thinks the vehicle is at {vehicle_plan.get_next_location()}."
        vehicle_plan.advance_plan() #advance plan by one step

        if len(vehicle_plan.get_plan_locations())>0:
            next_state = VehicleState.DRIVING
        else:
            next_state = VehicleState.IDLING
            self._vehicle_ids_avail.append(event.vehicle_id)
            #Check backlog
            if len(self._backlog_requests) > 0:
                #Get first request from backlog
                request = self._backlog_requests.pop(0)
                #Process request
                action = self._process_riderequest(request)
                return action

        return Action(
            vehicle_states={event.vehicle_id: next_state}
        )
    def update_vehicle_plans(self,
                             vehicle_plans: dict[uuid.UUID, VehiclePlan]):
        """
        Update the vehicle plan if more than one controller is acting and this controller 
        needs to keep track of vehicle plans
        """
        pass